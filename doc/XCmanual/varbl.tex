\newcommand{\A}[1]{{\tt A{#1}} & cross-sectional area of the section}
\newcommand{\ASupport}{{\tt A} & slab surface covered by the support}
\newcommand{\abSupport}{{\tt a,b} & section dimensions of the support}
\newcommand{\alphaX}{{\tt alpha} & shear shape factor}
\newcommand{\alphaY}[1]{{\tt alphaY{#1}} & coefficient of distortion about the local y-axis}
\newcommand{\alphaZ}[1]{{\tt alphaZ{#1}} & coefficient of distortion about the local z-axis}
\newcommand{\analysis}{{\tt analysis} & type of analysis to be performed. Some predefined types can be selected: \\
& {\tt from solution import predefined\_solutions as ps} \\
& {\tt pEF=xc.ProblemaEF()}\\
& {\tt ps.simple\_static\_linear(pEF)} for linear static analysis \\
& {\tt ps.simple\_newton\_raphson(pEF)} for non linear analysis using Newton Raphson algorithm to solve the equation \\
& {\tt ps.simple\_newton\_raphson\_band\_gen(pEF)} \\
& {\tt ps.simple\_static\_modified\_newton(pEF)} for non linear analysis using the modified Newton Raphson algorithm to solve the equation \\
& {\tt ps.penalty\_newton\_raphson(pEF)} \\
& {\tt ps.frequency\_analysis(p)} \\
}
\newcommand{\bX}{{\tt b} & width}
\newcommand{\dEff}[1]{{\tt d} & effective depth #1}
\newcommand{\defSecc}{{\tt defSecc} & name identifying the class object used to define the properties of the section}
\newcommand{\E}{{\tt E} & elastic modulus}
\newcommand{\EI}{{\tt EI} & flexural rigidity of the section}
\newcommand{\Es}{{\tt Es} & elastic modulus}
\newcommand{\epsSMax}{{\tt epsSMax} & maximum strain in steel}
\newcommand{\epsCMin}{{\tt epsCMin} & minimum strain in concrete}
\newcommand{\EIy}[1]{{\tt EIy{#1}} & product of $E_{steel} \times I_y$ }
\newcommand{\EIz}[1]{{\tt EIz{#1}} & product of $E_{steel} \times I_z$} 
\newcommand{\eyd}[1]{{\tt eyd{#1}} & design strain at yield point}
\newcommand{\eyk}[1]{{\tt eyk{#1}} & characteristic strain at yield point}
\newcommand{\fck}{{\tt fck} & characteristic compressive strength of concrete}
\newcommand{\fmaxk}[1]{{\tt fmaxk{#1}} & characteristic value of the ultimate strength}
\newcommand{\fy}[1]{{\tt fy{#1}} &  yield strength}
\newcommand{\fyd}[1]{{\tt fyd{#1}} & design value of the yield strength}
\newcommand{\fyk}[1]{{\tt fyk{#1}} & characteristic value of the yield strength}
\newcommand{\fyn}[1]{{\tt fyn{#1}} &  stress at which material reaches plastic state in compression}
\newcommand{\fyp}[1]{{\tt fyp{#1}} & stress at which material reaches plastic state in tension}
\newcommand{\gammaS}{{\tt gammaS} & partial factor}
\newcommand{\G}[1]{{\tt G{#1}} & transverse modulus of elasticity}

\newcommand{\getAMzOne}{{\tt getAMz1} & returns the bending moment about the local Z axis applied to the back end of the element}
\newcommand{\getAMzTwo}{{\tt getAMz2} & returns the bending moment about the local Z axis applied to the front end of the element}
\newcommand{\getANTwo}{{\tt getAN2} & returns the axial force applied to the front end of the element}
\newcommand{\getAVyOne}{{\tt  getAVy1} & returns the shear force in local Y axis appliend on the back end of the element}
\newcommand{\getAVyTwo}{{\tt  getAVy2} & returns the shear force in local Y axis direction applied on the front end of the element}
\newcommand{\getAVzOne}{{\tt  getAVz1} & returns the shear force in local Z axis appliend on the back end of the element}
\newcommand{\getAVzTwo}{{\tt  getAVz2} & returns the shear force in local Z axis direction applied on the front end of the element}

\newcommand{\getMOne}{{\tt getM1} & returns the bending moment at the back end of the element}
\newcommand{\getMTwo}{{\tt getM2} & returns the bending moment at the front end of the element}
\newcommand{\getMyOne}{{\tt getMy1} & returns the bending moment about the local Y axis at the back end of the element}
\newcommand{\getMyTwo}{{\tt  getMy2} &  returns the bending moment  about the local Y axis at the front end of the element}
\newcommand{\getMzOne}{{\tt getMz1} & returns the bending moment about the local Z axis at the back end of the element}
\newcommand{\getMzTwo}{{\tt  getMz2} &  returns the bending moment  about the local Z axis at the front end of the element}

\newcommand{\getN}{{\tt getN} & returns the mean value of the axial force at the the element $N=\cfrac{N_1 + N_2}{2}$}
\newcommand{\getNOne}{{\tt getN1} & returns the axial force at the back end of the element}
\newcommand{\getNTwo}{{\tt getN2} & returns the axial force at the front end of the element}
\newcommand{\getT}{{\tt getT} & returns the mean value of the torsional moment at the the element }
\newcommand{\getTOne}{{\tt getT1} & returns the torsional moment at the back end of the element}
\newcommand{\getTTwo}{{\tt getT2} & returns the torsional moment at the front end of the element}
\newcommand{\getV}{{\tt getV} & returns the shear force at the central section of the element}
\newcommand{\getVDirEjeFuerteLocales}{{\tt getVDirEjeFuerteLocales()} & \\ & returns a vector, expressed in local coordinates, that defines the strong axis orientation}
\newcommand{\getVDirEjeDebilLocales}{{\tt getVDirEjeDebilLocales()} & \\ & returns a vector, expressed in local coordinates, that defines the weak axis orientation}
\newcommand{\getAnguloEjeFuerte}{{\tt getAnguloEjeFuerte()} & returns the angle between the strong axis and the plane XZ of the element}
\newcommand{\getAnguloEjeDebil}{{\tt getAnguloEjeDebil()} & returns the angle between the weak axis and the plane XZ of the element}
\newcommand{\getVDirEjeFuerteGlobales}{{\tt getVDirEjeFuerteGlobales()} & \\ & returns a vector, expressed in global coordinates, that defines the strong axis orientation}
\newcommand{\getVDirEjeDebilGlobales}{{\tt getVDirEjeDebilGlobales()} & \\ & returns a vector, expressed in global coordinates, that defines the weak axis orientation}

\newcommand{\getVOne}{{\tt getV1} & returns the shear force at the back end of the element}
\newcommand{\getVTwo}{{\tt getV2} & returns the shear force at the front end of the element}
\newcommand{\getVy}{{\tt getVy} & returns the element mean shear force in the local Y axis direction}
\newcommand{\getVyOne}{{\tt  getVy1} & returns the shear force in local Y axis direction at the back end of the element}
\newcommand{\getVyTwo}{{\tt  getVy2} & returns the shear force in local Y axis direction at the front end of the element}
\newcommand{\getVz}{{\tt getVz} & returns the element mean shear force in the local Z axis direction}
\newcommand{\getVzOne}{{\tt  getVz1} & returns the shear force in local Z axis direction at the back end of the element}
\newcommand{\getVzTwo}{{\tt  getVz2} & returns the shear force in local Z axis direction at the front end of the element}

\newcommand{\GJ}[1]{{\tt GJ{#1}} & product of $E_{steel} \times G$ }
\newcommand{\h}[1]{{\tt h} & overall depth #1}
\newcommand{\IAxisOne}[1]{{\tt I1{#1}} &  second moment of area about the axis through the centre of gravity and parallel to the width dimension (axis 1)}
\newcommand{\iAxisOne}[1]{{\tt i1{#1}} & bending radius of the section with regard to the axis 1}
\newcommand{\IAxisTwo}[1]{{\tt I2{#1}} &  second moment of area about the axis through the centre of gravity and parallel to the high dimension (axis 2)}
\newcommand{\iAxisTwo}[1]{{\tt i2{#1}} & bending radius of the section with regard to the axis 2}
\newcommand{\initialStrain}{{\tt initialStrain} & initial strain in the element}
\newcommand{\Iy}[1]{{\tt Iy{#1}} &  second moment of area about the local y-axis}

\newcommand{\Iz}[1]{{\tt Iz{#1}} &  second moment of area about the local z-axis}
\newcommand{\J}[1]{{\tt J{#1}} & torsional moment of inertia of the section }
\newcommand{\lSpan}{{\tt l} & span}
\newcommand{\length}[1]{{\tt l} & length}

\newcommand{\M}{{\tt M} & bending moment}
\newcommand{\Mcoup}{{\tt M} & coupled moment}
\newcommand{\mapInteractionDiagrams}{{\tt mapInteractionDiagrams} & \\ & data structure that links each section name and direction with the interaction diagram object to be used for its verification}
\newcommand{\mapSectionsDefinition}{{\tt mapSectionsDefinition} & \\ & data structure that links each section name and direction with the respective record that contains the section definition parameters }
\newcommand{\mapSectionsForEveryElement}{{\tt mapSectionsForEveryElement} & \\ & data structure, such that, for each shell element: {\tt mapSectionsForEveryElement[tagElem]=[nmbScc1,nmbScc2]}, where {\tt nmbScc1} and {\tt nmbScc2} are the names identifying the sections to be used in 1 and 2 directions respectively}
\newcommand{\preprocessor}{{\tt preprocessor} & preprocessor name}
\newcommand{\MeAxisOne}[1]{{\tt Me1{#1}} & yield moment of the rectangular section about the axis 1}
\newcommand{\N}{{\tt N} & axial force}
\newcommand{\name}[1]{{\tt name} & name identifying the {#1}}
\newcommand{\nDivIJ}{{\tt nDivIJ} & number of cells in IJ (width) direction}
\newcommand{\nDivJK}{{\tt nDivJK} & number of cells in JK  (height) direction}
\newcommand{\intForcCombFileName}[2]{{\tt intForcCombFileName} & name of the file where are to be found the shell element forces and moments obtained for each #2 combination, to be used in the verification of the {#1}. Directory path, file name and extension must be specified. The file contains a list of the following items (see the positive directions of the forces and moments in figure \ref{shell_forces_moments}):
$ULS_{id}\ elem_{id}\ N_1\ N_2\ N_{12}\ M_1 M_2\ M_{12}\ Q_1\ Q_2$ }

\newcommand{\outputFileName}{{\tt outputFileName} & name of the output files (directory path and file name without extension) where to write the results of the verification}  

\newcommand{\nmbSccOne}{{\tt nmbScc1} & name identifying the class object used to define the properties of the section orthogonal to direction 1}
\newcommand{\nmbSccTwo}{{\tt nmbScc2} & name identifying the class object used to define the properties of the section orthogonal to direction 1}
\newcommand{\nuX}{{\tt nu} & Poisson's ratio}
\newcommand{\Pload}{{\tt P} & concentrated load}
\newcommand{\qkSlab}{{\tt qk} & characteristic uniformly distributed load on the slab}
\newcommand{\qload}{{\tt q} &  uniformly distributed load}
\newcommand{\rhoX}{{\tt rho} &  mass density}
\newcommand{\procesResultVerifFIS}{{\tt procesResultVerifFIS} & name of the function to be used for carrying out the section verification, e.g. {\tt materials.sia262.crackControlSIA262.procesResultVerifFISSIA262PlanB}}
\newcommand{\procesResultVerifV}{{\tt procesResultVerifV} & name of the function to be used for carrying out the section verification, e.g. {\tt shearSIA262.procesResultVerifV}}
\newcommand{\V}{{\tt V} & shear force}
\newcommand{\Wyel}[1]{{\tt Wyel{#1}} & elastic section modulus about the local y-axis}
\newcommand{\Wzel}[1]{{\tt Wzel()} & elastic section modulus about the local z-axis}

%Elements variables
\newcommand{\ElementParam}
{
%{\tt getNodes} & \\ 
{\tt getIdxNodes} & vector containing the node index to be used in Vtk graphics \\
{\tt getDimension} & element dimension \\
{\tt getVtkCellType} & cell type for Vtk graphics\\ 
}

\newcommand{\ElementMeth}
{
{\tt commitState()} & the element is to commit its current state; returns $0$ if successful, a negative number if not\\
{\tt revertToLastCommit()} & the element is to set its current state to the last committed state; returns $0$ if successful, a negative number if not\\
{\tt revertToStart} & the element is to set its current state to the state it was at before the analysis started; returns $0$ if successful, a negative number if not\\
{\tt getNumDOF} & returns the number of DOF associated with the element; this should equal the sum of the DOFs at each of the external nodes \\
{\tt getResistingForce()} & returns the resisting force vector for the element; this is equal to the applied load due to element loads minus the loads at the nodes due to internal stresses in the element due to the current trial displacement, i.e. $ R_e = P_{e} - f_{R_e}(U_{trial}) $ \\ 
{\tt setDeadSRF} & assigns Stress Reduction Factor for element deactivation\\ 
{\tt getVtkCellType()} & returns cell type for Vtk graphics\\ 
{\tt getMEDCellType()} & returns cell type for MED file writing.\\
\multicolumn{2}{l}{{\tt getPosCentroid(geomInicial)}}\\
 & returns the element centroid position. \\
& {\tt geomInicial = True} to consider the initial geometry shape \\
& {\tt geomInicial = False} to consider the deformed geometry shape \\
\multicolumn{2}{l}{{\tt getCooCentroid(geomInicial)}} \\
 & returns the element centroid coordinates\\ 
& {\tt geomInicial = True} to consider the initial geometry shape \\
& {\tt geomInicial = False} to consider the deformed geometry shape \\
\multicolumn{2}{l}{{\tt getPoints(ni,nj,nk,geomInicial)}}\\
 & returns a uniform grid of points over the element.\\ 
& {\tt ni,nj,nk} number of divisions in i,j,k directions \\
& {\tt getLongTributaria} \emph{True} to consider the initial geometry shape, \emph{False} for the deformed geometry shape\\
{\tt resetTributarias()} & reset the tributary length, area and volume of connected nodes \\
{\tt vuelcaTributarias} & \\
\multicolumn{2}{l}{{\tt calculaLongsTributarias(geomInicial)}} \\
 & returns the tributary length associated with each node of the element; the parameter {\tt geomInicial = True} to consider the initial geometry shape in the calculation or {\tt geomInicial = False} for the deformed geometry shape\\
\multicolumn{2}{l}{{\tt getLongTributaria(Node)}} \\
 & returns the tributary length associated with the {\tt Node} given as argument\\
\multicolumn{2}{l}{{\tt getLongTributariaByTag(tag)}}\\
 & returns the tributary length associated with the node labelled with the {\tt tag} given as argument \\
\multicolumn{2}{l}{{\tt calculaAreasTributarias(geomInicial)}}\\
 & returns the tributary area associated with each node of the element; the parameter {\tt geomInicial = True} to consider the initial geometry shape in the calculation or {\tt geomInicial = False} for the deformed geometry shape\\
\multicolumn{2}{l}{{\tt getAreaTributaria(Node)}} \\
 & returns the tributary area associated with the {\tt Node} given as argument\\
\multicolumn{2}{l}{{\tt getAreaTributariaByTag(tag)}} \\
& returns the tributary area associated with the node labelled with the {\tt tag} given as argument \\
\multicolumn{2}{l}{{\tt calculaVolsTributarios(geomInicial)}} \\
 & returns the tributary volume associated with each node of the element; the parameter {\tt geomInicial = True} to consider the initial geometry shape in the calculation or {\tt geomInicial = False} for the deformed geometry shape\\
\multicolumn{2}{l}{{\tt getVolTributario(Node)}} \\
 & returns the tributary volume associated with the {\tt Node} given as argument\\
\multicolumn{2}{l}{{\tt getVolTributarioByTag(tag)}} \\
& returns the tributary volume associated with the node labelled with the {\tt tag} given as argument \\
{\tt getMaxCooNod(axisIdx)} & returns the maximum value among the coordinates in the {\tt axisIdx} axis of the external nodes associated with the element ({\tt axisIdx} adopts the values {\tt 0,1,}\ldots) \\
{\tt getMinCooNod(axisIdx)} & returns the minimum value among the coordinates in the {\tt axisIdx} axis of the external nodes associated with the element ({\tt axisIdx} adopts the values {\tt 0,1,}\ldots)\\
}


\newcommand{\ElementZERODParam}
{
{\tt getIVector} & vector in the element local x-axis direction\\
{\tt getJVector} & vector in the element local y-axis direction\\
{\tt getKVector} & vector in the element local z-axis direction\\
}

\newcommand{\ElementZERODMeth}
{
{\tt setupVectors(x,yp)} & establish orientation of element for the transformation matrix \\
& {\tt x} vector in global coordinates defining local x-axis \\
& {\tt yp} vector in global coordinates which lies in the local x-y plane for the element \\
& local z-axis is defined by the vector $\vec{z}=\vec{x}\times\vec{yp}$ \\
}

\newcommand{\ElementOneDParam}
{
{\tt getCoordTransf()} & returns the identifier of the coordinate-transformation associated with the element\\
}

\newcommand{\ElementOneDMeth}
{
{\tt getMEDCellType()} &  interface with MED data format for Salome\\
\multicolumn{2}{l}{{\tt vector2dUniformLoadGlobal(v)}} \\
 & applies a uniform surface load to the element; the value and direction of the load is defined by the 2D vector $\vec{v}$, expressed in the global coordinate system  \\
\multicolumn{2}{l}{{\tt vector2dUniformLoadLocal(v)}} \\
 & applies a uniform surface load to the element; the value and direction of the load is defined by the 2D vector $\vec{v}$, expressed in the element local coordinate system \\
\multicolumn{2}{l}{{\tt vector2dPointByRelDistLoadGlobal(d,v)}} \\
 &  applies a punctual force to the element; scalar $d$ specifies the offset distance from node 2 (toward node 1) where the force is applied, this distance is input as a length fraction (its value varies between 0 and 1); 2D vector $\vec{v}$ defines the force value and orientation, its coordinates are expressed in the global system\\
\multicolumn{2}{l}{{\tt vector2dPointByRelDistLoadLocal(d,v)}} \\
 &  applies a punctual force to the element; scalar $d$ specifies the offset distance from node 2 (toward node 1) where the force is applied, this distance is input as a length fraction (its value varies between 0 and 1); 2D vector $\vec{v}$ defines the force value and orientation, its coordinates are expressed in the element local system\\
\multicolumn{2}{l}{{\tt vector2dPointLoadGlobal(p,v)}} \\
 &  applies a punctual force to the element;  2D vector $\vec{p}$ defines the global coordinates of the point of application of the force; 2D vector $\vec{v}$ defines the force value and orientation (in global coordinates) \\
\multicolumn{2}{l}{{\tt vector2dPointLoadLocal(p,v)}} \\
 &  applies a punctual force to the element;  2D vector $\vec{p}$ defines the coordinates of the point of application of the force; 2D vector $\vec{v}$ defines the force value and orientation; both vectors are expressed in the element local-coordinate system \\
\multicolumn{2}{l}{{\tt vector3dUniformLoadGlobal(v)}} \\
 &  applies a uniform surface load to the element; the value and direction of the load is defined by the 3D vector $\vec{v}$, expressed in the global coordinate system\\
\multicolumn{2}{l}{{\tt vector3dUniformLoadLocal(v)}} \\
 &  applies a uniform surface load to the element; the value and direction of the load is defined by the 3D vector $\vec{v}$, expressed in the element local coordinate system\\
\multicolumn{2}{l}{{\tt vector3dPointByRelDistLoadGlobal(d,v)}} \\
 &  applies a punctual force to the element; scalar $d$ specifies the offset distance from node 2 (toward node 1) where the force is applied, this distance is input as a length fraction (its value varies between 0 and 1); 3D vector $\vec{v}$ defines the force value and orientation, its coordinates are expressed in the global system\\
\multicolumn{2}{l}{{\tt vector3dPointByRelDistLoadLocal(d,v)}} \\
 & applies a punctual force to the element; scalar $d$ specifies the offset distance from node 2 (toward node 1) where the force is applied, this distance is input as a length fraction (its value varies between 0 and 1); 3D vector $\vec{v}$ defines the force value and orientation, its coordinates are expressed in the element local-coordinate system \\
\multicolumn{2}{l}{{\tt vector3dPointLoadGlobal(p,v)}} \\
 & applies a punctual force to the element;  3D vector $\vec{p}$ defines the global coordinates of the point of application of the force; 3D vector $\vec{v}$ defines the force value and orientation (in global coordinates)\\
\multicolumn{2}{l}{{\tt vector3dPointLoadLocal(p,v)}} \\
 &  applies a punctual force to the element;  3D vector $\vec{p}$ defines the coordinates of the point of application of the force; 3D vector $\vec{v}$ defines the force value and orientation; both vectors are expressed in the element local-coordinate system \\
\multicolumn{2}{l}{{\tt strainLoad(PlanoDeformacion1,PlanoDeformacion2)}} \\
 &  This function creates an imposed strain load in the current load case. The first argument defines the deformation at element start and the second at the element's end.\\
{\tt getCooPuntos(ndiv)} & returns $ndiv-1$ equally-spaced points on the element\\
}

\newcommand{\ProtoTrussMeth}
{
{\tt getDim()} &  returns element dimension \\
{\tt getMaterial()} &  returns the material associated with the element \\
}

\newcommand{\ProtoBeamTwoDParam}
{
{\tt sectionProperties} & \\
}

\newcommand{\ProtoBeamThreeDParam}
{
{\tt sectionProperties} & \\
}

\newcommand{\BeamColumnWithSectionFDMeth}
{
{\tt getNumSections} & \\
{\tt getSections} & Returns element sections\\
}

\newcommand{\TrussBaseMeth}
{
{\tt getL} & returns the element length \\
}




\newcommand{\ZeroLengthMeth}
{
{\tt clearMaterials()} & clears all material definition of the element \\
\multicolumn{2}{l}{{\tt setMaterial(dir,matName)}} \\
 & assigns uni-axial materials to the different directions of the element\\
& {\tt dir}: integer representing the direction in which the uni-axial material acts: {\tt dir} is 0,1,2 for translation in the local x, y, z axes or 3, 4, 5 
for rotation about the local x, y, z axes.\\
& {\tt matName}: string representing the name of the material \\
{\tt getMaterials} &  \\
}


\newcommand{\ZeroLengthSectionMeth}
{
{\tt getSection()} & returns the section axial force-deformation associated with the element \\
{\tt getMaterial()} & returns the section axial force-deformation associated with the element \\
}

\newcommand{\MuelleMeth}
{
{\tt getN} & Returns the internal axial force $N$ in the element\\
}

\newcommand{\TrussMeth}
{
{\tt area} &  cross-sectional area of the element\\
{\tt getN} &  Returns the internal axial force $N$ in the element \\
}

\newcommand{\CorotTrussParam}
{
{\tt area} &  cross-sectional area of the element\\
}
\newcommand{\CorotTrussMeth}
{
{\tt getN} &  Returns the internal axial force $N$ in the element \\
}

